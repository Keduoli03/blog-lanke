<dialog id="md-lightbox-dialog" class="md-lightbox-dialog">
  <!-- 计数器：左上角 -->
  <div id="lb-counter" class="lb-counter">1 / 1</div>

  <!-- 工具栏：右上角 -->
  <div class="lightbox-toolbar">
    <button id="lb-zoom-out" class="lb-tool-btn" aria-label="缩小">
      <svg
        xmlns="http://www.w3.org/2000/svg"
        width="24"
        height="24"
        viewBox="0 0 24 24"
        fill="none"
        stroke="currentColor"
        stroke-width="2"
        stroke-linecap="round"
        stroke-linejoin="round"
        ><circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"
        ></line><line x1="8" y1="11" x2="14" y2="11"></line></svg
      >
    </button>
    <button id="lb-zoom-in" class="lb-tool-btn" aria-label="放大">
      <svg
        xmlns="http://www.w3.org/2000/svg"
        width="24"
        height="24"
        viewBox="0 0 24 24"
        fill="none"
        stroke="currentColor"
        stroke-width="2"
        stroke-linecap="round"
        stroke-linejoin="round"
        ><circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"
        ></line><line x1="11" y1="8" x2="11" y2="14"></line><line x1="8" y1="11" x2="14" y2="11"
        ></line></svg
      >
    </button>
    <button id="lb-rotate" class="lb-tool-btn" aria-label="旋转">
      <svg
        xmlns="http://www.w3.org/2000/svg"
        width="24"
        height="24"
        viewBox="0 0 24 24"
        fill="none"
        stroke="currentColor"
        stroke-width="2"
        stroke-linecap="round"
        stroke-linejoin="round"
        ><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"></path><path d="M3 3v5h5"
        ></path></svg
      >
    </button>
    <button id="md-lightbox-close" class="lb-tool-btn close-btn" aria-label="关闭">
      <svg
        xmlns="http://www.w3.org/2000/svg"
        width="24"
        height="24"
        viewBox="0 0 24 24"
        fill="none"
        stroke="currentColor"
        stroke-width="2"
        stroke-linecap="round"
        stroke-linejoin="round"
        ><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg
      >
    </button>
  </div>

  <!-- 导航按钮 -->
  <button id="lb-prev" class="lb-nav-btn lb-prev" aria-label="上一张">
    <svg
      xmlns="http://www.w3.org/2000/svg"
      width="32"
      height="32"
      viewBox="0 0 24 24"
      fill="none"
      stroke="currentColor"
      stroke-width="2"
      stroke-linecap="round"
      stroke-linejoin="round"><polyline points="15 18 9 12 15 6"></polyline></svg
    >
  </button>
  <button id="lb-next" class="lb-nav-btn lb-next" aria-label="下一张">
    <svg
      xmlns="http://www.w3.org/2000/svg"
      width="32"
      height="32"
      viewBox="0 0 24 24"
      fill="none"
      stroke="currentColor"
      stroke-width="2"
      stroke-linecap="round"
      stroke-linejoin="round"><polyline points="9 18 15 12 9 6"></polyline></svg
    >
  </button>

  <div class="lightbox-content-wrapper">
    <div class="lightbox-image-container">
      <img id="md-lightbox-img" alt="" />
    </div>
    <p id="md-lightbox-caption"></p>
  </div>
</dialog>

<style>
  .md-lightbox-dialog[open] {
    position: fixed !important;
    inset: 0 !important;
    width: 100% !important;
    height: 100% !important;
    min-width: 100vw !important;
    min-height: 100vh !important;

    margin: 0 !important;
    border: none !important;
    padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom)
      env(safe-area-inset-left) !important;

    display: flex !important;
    justify-content: center !important;
    align-items: center !important;

    background: transparent !important;
    z-index: 2147483647 !important;
    overflow: hidden !important;
  }

  .lightbox-content-wrapper {
    display: flex !important;
    flex-direction: column !important;
    align-items: center !important;
    justify-content: center !important;
    width: 100% !important;
    height: 100% !important;
    pointer-events: none; /* 让点击穿透到 dialog 用于关闭 */
  }

  .lightbox-image-container {
    position: relative !important;
    display: flex !important;
    justify-content: center !important;
    align-items: center !important;
    max-width: 100% !important;
    max-height: calc(100vh - 4rem) !important;
    width: 100% !important;
    height: 100% !important;
    pointer-events: auto;
  }

  #md-lightbox-img {
    max-width: 90vw !important;
    max-height: 90vh !important;
    width: auto !important;
    height: auto !important;
    object-fit: contain !important;
    display: block !important;
    transition: transform 0.3s cubic-bezier(0.2, 0, 0.2, 1);
    cursor: grab;
    /* 强制清除可能继承的行内样式限制 */
    min-width: 0 !important;
    min-height: 0 !important;
  }

  #md-lightbox-img:active {
    cursor: grabbing;
  }

  #md-lightbox-caption {
    position: absolute !important;
    bottom: 1rem !important;
    left: 50% !important;
    transform: translateX(-50%) !important;
    margin: 0 !important;
    color: #fff !important;
    text-align: center !important;
    max-width: 90% !important;
    padding: 0.5rem 1rem !important;
    background: rgba(0, 0, 0, 0.5);
    border-radius: 4px;
    word-wrap: break-word !important;
    line-height: 1.5 !important;
    pointer-events: auto;
    z-index: 10;
  }

  .md-lightbox-dialog::backdrop {
    position: fixed !important;
    inset: 0 !important;
    width: 100vw !important;
    height: 100vh !important;
    background: rgba(0, 0, 0, 0.9) !important;
  }

  /* 工具栏样式 */
  .lightbox-toolbar {
    position: fixed;
    top: 1.5rem;
    right: 1.5rem;
    display: flex;
    align-items: center;
    gap: 0.75rem;
    z-index: 2147483648;
    pointer-events: auto;
  }

  .lb-counter {
    position: fixed;
    top: 1.5rem;
    left: 1.5rem;
    z-index: 2147483648;
    color: rgba(255, 255, 255, 0.9);
    font-size: 0.9rem;
    font-weight: 500;
    text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
    font-feature-settings: 'tnum';
    font-variant-numeric: tabular-nums;
    background: rgba(0, 0, 0, 0.3);
    padding: 0.25rem 0.75rem;
    border-radius: 999px;
    backdrop-filter: blur(4px);
    border: 1px solid rgba(255, 255, 255, 0.1);
    pointer-events: none;
  }

  .lb-tool-btn {
    width: 2.5rem;
    height: 2.5rem;
    border-radius: 50%;
    background: rgba(255, 255, 255, 0.1);
    border: 1px solid rgba(255, 255, 255, 0.2);
    color: white;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: all 0.2s ease;
    padding: 0;
    backdrop-filter: blur(4px);
  }

  .lb-tool-btn:hover {
    background: rgba(255, 255, 255, 0.25);
    transform: scale(1.05);
  }

  .lb-tool-btn.close-btn {
    background: rgba(255, 50, 50, 0.2);
    border-color: rgba(255, 50, 50, 0.3);
    margin-left: 0.5rem;
  }
  .lb-tool-btn.close-btn:hover {
    background: rgba(255, 50, 50, 0.4);
  }

  /* 导航按钮样式 */
  .lb-nav-btn {
    position: fixed;
    top: 50%;
    transform: translateY(-50%);
    width: 3rem;
    height: 3rem;
    border-radius: 50%;
    background: rgba(255, 255, 255, 0.1);
    border: none;
    color: white;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: all 0.2s ease;
    z-index: 2147483648;
    pointer-events: auto;
    backdrop-filter: blur(4px);
  }

  .lb-nav-btn:hover {
    background: rgba(255, 255, 255, 0.2);
    transform: translateY(-50%) scale(1.1);
  }

  .lb-prev {
    left: 1.5rem;
  }
  .lb-next {
    right: 1.5rem;
  }

  /* 移动端适配 */
  @media (max-width: 768px) {
    .lightbox-toolbar {
      top: 1rem;
      right: 1rem;
      gap: 0.5rem;
    }
    .lb-counter {
      top: 1rem;
      left: 1rem;
    }
    .lb-tool-btn {
      width: 2.25rem;
      height: 2.25rem;
    }
    .lb-nav-btn {
      width: 2.5rem;
      height: 2.5rem;
      background: transparent;
    }
    .lb-prev {
      left: 0.5rem;
    }
    .lb-next {
      right: 0.5rem;
    }
  }

  body {
    margin: 0 !important;
    padding: 0 !important;
  }
  .md-lightbox img,
  .prose img {
    cursor: zoom-in !important;
  }
</style>

<script is:inline>
  function initLightbox() {
    const dialog = document.getElementById('md-lightbox-dialog')
    const img = document.getElementById('md-lightbox-img')
    const caption = document.getElementById('md-lightbox-caption')
    const counter = document.getElementById('lb-counter')

    // Controls
    const btnZoomIn = document.getElementById('lb-zoom-in')
    const btnZoomOut = document.getElementById('lb-zoom-out')
    const btnRotate = document.getElementById('lb-rotate')
    const btnClose = document.getElementById('md-lightbox-close')
    const btnPrev = document.getElementById('lb-prev')
    const btnNext = document.getElementById('lb-next')
    const imgContainer = document.querySelector('.lightbox-image-container')

    if (dialog && dialog.parentElement !== document.body) {
      document.body.appendChild(dialog)
    }

    let state = {
      scale: 1,
      rotate: 0,
      translateX: 0,
      translateY: 0,
      isDragging: false,
      startX: 0,
      startY: 0,
      index: -1,
      gallery: [], // { url, alt, title, el }
    }

    // Scroll locking
    let preventScroll = null
    const lockScroll = () => {
      document.documentElement.classList.add('lightbox-open')
      preventScroll = (ev) => {
        ev.preventDefault()
        ev.stopPropagation()
        if (typeof ev.stopImmediatePropagation === 'function') ev.stopImmediatePropagation()
      }
      window.addEventListener('wheel', preventScroll, { passive: false, capture: true })
      window.addEventListener('touchmove', preventScroll, { passive: false, capture: true })
    }

    const unlockScroll = () => {
      document.documentElement.classList.remove('lightbox-open')
      if (preventScroll) {
        window.removeEventListener('wheel', preventScroll, { capture: true })
        window.removeEventListener('touchmove', preventScroll, { capture: true })
        preventScroll = null
      }
    }

    // Dragging Logic
    const handleDragStart = (e) => {
      if (state.scale <= 1) return
      state.isDragging = true

      // Support both mouse and touch
      const clientX = e.type.includes('mouse') ? e.clientX : e.touches[0].clientX
      const clientY = e.type.includes('mouse') ? e.clientY : e.touches[0].clientY

      state.startX = clientX - state.translateX
      state.startY = clientY - state.translateY

      if (img) img.style.cursor = 'grabbing'
      e.preventDefault() // Prevent default drag behavior
    }

    const handleDragMove = (e) => {
      if (!state.isDragging) return

      e.preventDefault()
      const clientX = e.type.includes('mouse') ? e.clientX : e.touches[0].clientX
      const clientY = e.type.includes('mouse') ? e.clientY : e.touches[0].clientY

      state.translateX = clientX - state.startX
      state.translateY = clientY - state.startY

      updateTransform()
    }

    const handleDragEnd = () => {
      state.isDragging = false
      if (img) img.style.cursor = state.scale > 1 ? 'grab' : 'zoom-in'
    }

    // Bind drag events
    if (imgContainer) {
      imgContainer.addEventListener('mousedown', handleDragStart)
      imgContainer.addEventListener('touchstart', handleDragStart, { passive: false })

      window.addEventListener('mousemove', handleDragMove)
      window.addEventListener('touchmove', handleDragMove, { passive: false })

      window.addEventListener('mouseup', handleDragEnd)
      window.addEventListener('touchend', handleDragEnd)
    }

    // Link Detection Logic
    const isLightboxLink = (a) => {
      if (!a) return false
      const target = a.getAttribute('target')
      const rel = (a.getAttribute('rel') || '').toLowerCase()
      if (target === '_blank' || rel.includes('noopener') || rel.includes('noreferrer'))
        return false
      if (a.getAttribute('data-no-lightbox') === 'true') return false
      if (
        a.closest('#sidebar') ||
        a.closest('.sidebar-header') ||
        a.closest('.mobile-nav') ||
        a.closest('.md-lightbox-exclude')
      )
        return false

      const href = a.getAttribute('href') || ''
      const classes = a.classList
      const hasData = a.hasAttribute('data-lightbox') || a.hasAttribute('data-pswp-src')
      const isImageHref = /\.(jpg|jpeg|png|webp|gif)(\?.*)?$/i.test(href)

      return (
        hasData ||
        classes.contains('md-lightbox') ||
        classes.contains('pswp-link') ||
        classes.contains('post-image-link') ||
        isImageHref
      )
    }

    // Helper to extract info from element
    const getLightboxInfo = (el) => {
      let url = '',
        rawAlt = '',
        rawTitle = ''
      if (el.tagName === 'A') {
        const childImg = el.querySelector('img')

        // Get potential URL from attributes
        let attrUrl =
          el.getAttribute('data-pswp-src') ||
          el.getAttribute('data-lightbox') ||
          el.getAttribute('href')

        // Logic to determine best URL:
        // 1. If we have a child image, checks if attrUrl is a "raw" relative path (e.g. "附件/...") which won't resolve.
        // 2. If attrUrl is relative and childImg has a valid currentSrc (processed by Astro), use currentSrc.
        // 3. Otherwise use attrUrl.

        if (childImg) {
          const isAbsolute =
            attrUrl && (/^(?:[a-z]+:)?\/\//i.test(attrUrl) || attrUrl.startsWith('/'))
          if (attrUrl && isAbsolute) {
            url = attrUrl
          } else {
            // Fallback: try to find the best quality image from srcset or currentSrc

            // 1. Try to parse srcset for the largest image
            if (childImg.srcset) {
              const candidates = childImg.srcset.split(',').map((s) => {
                const parts = s.trim().split(/\s+/)
                const src = parts[0]
                // Support both w (width) and x (density) descriptors
                // e.g. "img-300.jpg 300w" or "img-2x.jpg 2x"
                let score = 0

                for (let i = 1; i < parts.length; i++) {
                  const part = parts[i]
                  if (part.endsWith('w')) {
                    score = parseInt(part)
                    break
                  } else if (part.endsWith('x')) {
                    // Assume base width 1000 for 1x to compare with w descriptors
                    // This is heuristic but usually 2x is better than 1x
                    score = parseFloat(part) * 1000
                    break
                  }
                }
                // If no descriptor, assume 0 (lowest priority)

                return { src, score }
              })

              // Sort by score descending
              candidates.sort((a, b) => b.score - a.score)

              if (candidates.length > 0) {
                url = candidates[0].src
              }
            }

            // 2. If no srcset or failed, use currentSrc or src or fallback to attrUrl
            if (!url) {
              url = childImg.currentSrc || childImg.src || attrUrl || ''
            }
          }

          rawAlt = el.getAttribute('data-alt') || childImg.getAttribute('alt') || ''
          rawTitle = el.getAttribute('data-title') || childImg.getAttribute('title') || ''
        } else {
          url = attrUrl || ''
          rawAlt = el.getAttribute('data-alt') || ''
          rawTitle = el.getAttribute('data-title') || ''
        }
      } else if (el.tagName === 'IMG') {
        url = el.getAttribute('data-pswp-src') || el.currentSrc || el.src || ''
        rawAlt = el.getAttribute('alt') || ''
        rawTitle = el.getAttribute('title') || ''
      }
      return { url, rawAlt, rawTitle, el }
    }

    const sanitizeCaption = (text) => {
      const s = (text || '').trim()
      if (!s) return ''
      if (/^\|\s*\d+(\s*x\s*\d+)?\s*$/i.test(s)) return ''
      const cleaned = s.replace(/\|\s*\d+(\s*x\s*\d+)?\s*$/i, '').trim()
      return cleaned
    }

    // Collect all images in the page
    const buildGallery = () => {
      const candidates = document.querySelectorAll('a, img')
      const gallery = []
      const seen = new Set()

      candidates.forEach((el) => {
        // Exclude specific areas
        if (
          el.closest('#comment-section') ||
          el.closest('.artalk') ||
          el.closest('.atk-layer-wrap') ||
          el.closest('.atk-layer-dialog-wrap') ||
          el.closest('#sidebar') ||
          el.closest('.sidebar-header') ||
          el.closest('.mobile-nav') ||
          el.closest('#mobile-navbar') ||
          el.closest('.md-lightbox-exclude') ||
          el.classList.contains('atk-captcha-img')
        )
          return

        // Skip if already processed (e.g. img inside a)
        if (seen.has(el)) return

        let info = null
        if (el.tagName === 'A' && isLightboxLink(el)) {
          info = getLightboxInfo(el)
          // Mark child img as seen
          const childImg = el.querySelector('img')
          if (childImg) seen.add(childImg)
        } else if (el.tagName === 'IMG') {
          // Check if parent is a lightbox link, if so, skip (it will be caught by A)
          const parentA = el.closest('a')
          if (parentA && isLightboxLink(parentA)) return

          // Check exclusion logic for img
          const altLower = (el.getAttribute('alt') || '').toLowerCase()
          const isEmoji =
            el.classList.contains('artalk-emoji') ||
            el.classList.contains('atk-emoji') ||
            el.hasAttribute('data-emoji') ||
            /emoji|表情/.test(altLower)
          const isUiIcon =
            /logo|icon|avatar|徽标|图标/.test(altLower) ||
            el.classList.contains('logo') ||
            el.classList.contains('icon') ||
            el.classList.contains('avatar')

          if (
            !isEmoji &&
            !isUiIcon &&
            !el.hasAttribute('data-no-lightbox') &&
            !el.classList.contains('no-lightbox')
          ) {
            info = getLightboxInfo(el)
          }
        }

        if (info && info.url) {
          gallery.push(info)
          seen.add(el)
        }
      })
      return gallery
    }

    // Actions
    const updateTransform = () => {
      if (img) {
        img.style.transform = `translate(${state.translateX}px, ${state.translateY}px) scale(${state.scale}) rotate(${state.rotate}deg)`
        img.style.cursor = state.scale > 1 ? (state.isDragging ? 'grabbing' : 'grab') : 'zoom-in'
      }
    }

    const updateImageContent = () => {
      if (state.index < 0 || state.index >= state.gallery.length) {
        return
      }
      const item = state.gallery[state.index]

      const alt = sanitizeCaption(item.rawAlt)
      const title = sanitizeCaption(item.rawTitle)
      const captionText = title || alt || '' // 移除 "未命名图片" 占位符，保持清爽

      if (img) {
        img.src = item.url
        img.alt = alt

        // 清除可能残留的内联样式（比如之前被JS设置过，或者复制了原图的style）
        img.removeAttribute('width')
        img.removeAttribute('height')
        img.style.width = ''
        img.style.height = ''
        img.style.maxWidth = ''
        img.style.maxHeight = ''

        // Reset transform
        state.scale = 1
        state.rotate = 0
        state.translateX = 0
        state.translateY = 0
        updateTransform()
      }
      if (caption) {
        caption.textContent = captionText
        caption.style.display = captionText ? 'block' : 'none'
      }
      if (counter) {
        counter.textContent = `${state.index + 1} / ${state.gallery.length}`
      }

      // Update Nav Buttons visibility
      if (btnPrev) btnPrev.style.display = state.gallery.length > 1 ? 'flex' : 'none'
      if (btnNext) btnNext.style.display = state.gallery.length > 1 ? 'flex' : 'none'
      // Disable if at ends (optional, currently loop is better? Or stop?)
      // Let's implement loop
      if (btnPrev) btnPrev.style.opacity = state.gallery.length > 1 ? '1' : '0.5'
      if (btnNext) btnNext.style.opacity = state.gallery.length > 1 ? '1' : '0.5'
    }

    const openAt = (targetEl) => {
      state.gallery = buildGallery()
      // Find index
      // We need to match by element reference.
      // Since buildGallery iterates DOM, references should match.
      // However, if we clicked an IMG inside an A, targetEl might be IMG, but gallery has A.

      let index = -1

      // Try exact match
      index = state.gallery.findIndex((item) => item.el === targetEl)

      // If not found, try finding parent A
      if (index === -1 && targetEl.tagName === 'IMG') {
        const parentA = targetEl.closest('a')
        if (parentA) {
          index = state.gallery.findIndex((item) => item.el === parentA)
        }
      }

      // If still not found (maybe logic mismatch), just add it as single item
      if (index === -1) {
        const info = getLightboxInfo(targetEl)
        if (info.url) {
          state.gallery = [info]
          index = 0
        }
      }

      if (index !== -1) {
        state.index = index
        updateImageContent()

        if (dialog) {
          if (typeof dialog.showModal === 'function') dialog.showModal()
          else dialog.setAttribute('open', '')
        }
        lockScroll()
      }
    }

    const nextImage = () => {
      if (state.gallery.length <= 1) return
      state.index = (state.index + 1) % state.gallery.length
      updateImageContent()
    }

    const prevImage = () => {
      if (state.gallery.length <= 1) return
      state.index = (state.index - 1 + state.gallery.length) % state.gallery.length
      updateImageContent()
    }

    const zoomIn = () => {
      state.scale = Math.min(state.scale + 0.25, 5)
      updateTransform()
    }

    const zoomOut = () => {
      state.scale = Math.max(state.scale - 0.25, 0.1)
      updateTransform()
    }

    const rotate = () => {
      state.rotate = (state.rotate + 90) % 360
      updateTransform()
    }

    const closeLightbox = () => {
      if (dialog) {
        if (typeof dialog.close === 'function') dialog.close()
        else dialog.removeAttribute('open')
      }

      // Clear image source to avoid flash of old content when reopening
      if (img) {
        img.src = ''
        img.removeAttribute('src')
        img.alt = ''
      }

      unlockScroll()
    }

    // Event Listeners
    const handleClick = (e) => {
      const t = e.target

      if (!(t instanceof Element)) return
      if (dialog?.open && dialog.contains(t)) return // Let dialog handle its own clicks

      // Global Exclusion: Sidebar, Comments, etc.
      const exclusion =
        t.closest('#sidebar') ||
        t.closest('.sidebar-header') ||
        t.closest('.sidebar-logo') ||
        t.closest('#comment-section') ||
        t.closest('.artalk') ||
        t.closest('.mobile-nav') ||
        t.closest('#mobile-navbar') ||
        t.closest('.md-lightbox-exclude')

      if (exclusion) {
        return
      }

      // Determine target
      let targetEl = null
      const a = t.closest('a')
      if (a && isLightboxLink(a)) {
        targetEl = a
      } else {
        const imgEl = t.closest('img')
        // Check if img is valid lightbox target
        if (imgEl) {
          const altLower = (imgEl.getAttribute('alt') || '').toLowerCase()
          const isEmoji = imgEl.classList.contains('artalk-emoji') || /emoji|表情/.test(altLower)
          // Simplified check since we have global exclusion for sidebar/logo
          const isUiIcon =
            /logo|icon|avatar|徽标|图标/.test(altLower) ||
            imgEl.classList.contains('logo') ||
            imgEl.classList.contains('icon')

          if (
            !isEmoji &&
            !isUiIcon &&
            !imgEl.hasAttribute('data-no-lightbox') &&
            !imgEl.classList.contains('no-lightbox')
          ) {
            targetEl = imgEl
          }
        }
      }

      if (targetEl) {
        e.preventDefault()
        e.stopPropagation()
        openAt(targetEl)
      }
    }

    // Bind controls
    btnZoomIn?.addEventListener('click', (e) => {
      e.stopPropagation()
      zoomIn()
    })
    btnZoomOut?.addEventListener('click', (e) => {
      e.stopPropagation()
      zoomOut()
    })
    btnRotate?.addEventListener('click', (e) => {
      e.stopPropagation()
      rotate()
    })
    btnClose?.addEventListener('click', (e) => {
      e.stopPropagation()
      closeLightbox()
    })
    btnPrev?.addEventListener('click', (e) => {
      e.stopPropagation()
      prevImage()
    })
    btnNext?.addEventListener('click', (e) => {
      e.stopPropagation()
      nextImage()
    })

    // Dialog click to close (background)
    dialog?.addEventListener('click', (e) => {
      if (
        e.target === dialog ||
        e.target.classList.contains('lightbox-content-wrapper') ||
        e.target.classList.contains('lightbox-image-container')
      ) {
        closeLightbox()
      }
    })

    // Keyboard
    const handleKeydown = (e) => {
      if (!dialog?.open) return
      if (e.key === 'Escape') {
        e.preventDefault()
        closeLightbox()
      }
      if (e.key === 'ArrowLeft') {
        e.preventDefault()
        prevImage()
      }
      if (e.key === 'ArrowRight') {
        e.preventDefault()
        nextImage()
      }
      if (e.key === '+' || e.key === '=') {
        e.preventDefault()
        zoomIn()
      }
      if (e.key === '-' || e.key === '_') {
        e.preventDefault()
        zoomOut()
      }
    }
    window.addEventListener('keydown', handleKeydown)

    document.addEventListener('click', handleClick, { capture: true })

    // Cleanup
    return () => {
      document.removeEventListener('click', handleClick, { capture: true })
      window.removeEventListener('keydown', handleKeydown)
      unlockScroll()
    }
  }

  let cleanup = initLightbox()

  const handleNavigation = () => {
    if (cleanup) cleanup()
    cleanup = initLightbox()
  }

  document.addEventListener('astro:page-load', handleNavigation)
  document.addEventListener('astro:after-swap', handleNavigation)
</script>
